## 二进制数的手算乘法

无符号整数（二进制）的手算方法与十进制类似---“逐位相乘，错位相加”
## 无符号数乘法的电路结构、运行原理

+ 两个n bit 无符号数的乘法运算，可拆解为n轮加法运算
+ 根据乘数的各个bit，决定每一轮加法运算
+ 每一轮加法运算需要与上一轮加法运算的结果“错位相加”
初始化：
1. 将被乘数、乘数分别放入寄存器X、Y中
2. 乘积寄存器P 置为0
3. 计数器C的初始值置为n（n为乘数的位数）
**特殊情况**：当被乘数、乘数中有一个为全0时，结果直接得0，不需要再进行后续的运算步骤

重复n轮加法、位移运算，直到计数器$C_n=0$：
1. 将乘数寄存器Y的最低位，送入“控制逻辑”进行判断
2. ①若Y的最低位为1，则执行加法，运算结果写回P（注意加法产生的进位需保存至进位触发器C）;②若Y的最低位为0，则什么也不做
3. 将\[C,P,Y]视为整体，逻辑右移一位
4. 计数器$C_n$减1

结束（计数器$C_n=0$）：
1. 乘法运算的结果用2n位暂存（寄存器P、寄存器Y）
2. 在很多计算机框架中，通常仅保留n位作为乘积结果（因此，运算结果可能发生溢出）

溢出判断：
+ 若高n位不全为0，说明发生溢出，此时可将OF标志位置1
>[!important] 为什么不用CF=1标志无符号整数发生溢出
>CF通常只记录加减运算的溢出，无论是带符号整数还是无符号整数，乘除法都使用OF标志溢出。无符号整数乘法溢出时，OF被置为1时，CF也会被置为1.

溢出处理：
+ 忽略“溢出”
+ 在乘法指令之后执行一条溢出自陷指令。该指令会检查OF标志位。若OF=1，则执行系统的“异常处理程序”
## 电路结构中，各个部件的作用