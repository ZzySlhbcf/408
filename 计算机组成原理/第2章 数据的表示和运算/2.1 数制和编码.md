# 2.1.2 定点数的编码表示

## 2. 机器数的定点表示

在计算机中, 小数和整数不一样, **整数可以连续表示, 但小数是离散的, 所以并不是每个十进制小数都可以准确地用二进制表示**. 例如0.3, 无论经过多少次乘二取整转换都无法得到精确的结果
另外, 对于基数越大的数, 同样数位下, 其能表示的真值数量越多, 例如, 四位定点小数, 若基数为10,  则可以表示的正数范围为0.000-0.999, 总共1000个数. 若基数为2, 则可以表示的正数范围为0.000-0.111, 总共8个数, 同样散落在0-1的区间内, 显然, 基数为10时, 密度更高, 精度更高, **任意的二进制小数都可以用十进制小数表示, 而却不是所有的十进制小数都可以用二进制表示**

## 3. 原码、补码、反码、移码

机器数随真值的单调性

![[机器数随真值的单调性.png]]

原反补码的转换 

![[原反补码的转换.png]]


对于n+1位的机器数

|     | 正数                                   | 负数                                   | 范围                   |
| --- | ------------------------------------ | ------------------------------------ | -------------------- |
| 原码  | 0+绝对值                                | 1+绝对值                                | $-(2^n-1)\sim 2^n-1$ |
| 反码  | 0+绝对值                                | 1+按位取反                               | $-(2^n-1)\sim 2^n-1$ |
| 补码  | 0+绝对值                                | 基于反码, 末位+1                           | $-2^n\sim{2}^n-1$    |
| 移码  | $[x]_{移}=2^n+x(-2^n\leqslant x<2^n)$ | $[x]_{移}=2^n+x(-2^n\leqslant x<2^n)$ | $-2^n\sim{2}^n-1$    |

### 原码表示法

最高位为符号位

>[!info] 若字长为n+1,  则原码整数的表示范围为$-(2^n-1)\leqslant x\leqslant2^n-1$

+ 与真值的对应关系简单、直观,  与真值的转换简单
+ 用原码实现**乘除**运算比较简便
+ 0的表示不唯一, 有$\pm0$两个编码
+ 原码的加减运算比较复杂

### 补码表示法

> 正数与原码相同,  负数是原码除符号位以外按位取反

>[!info] 若字长为n+1,  则原码整数的表示范围为$-2^n\leqslant x\leqslant2^n-1$ (比原码多表示$-2^n$)

>[!important] 模运算
>在模运算中, 一个数与它除以"模"后得到的余数是等价的, $A=B+K*M$, 则记为$A\equiv B (\mod M)$
>在补码运算中, $[A]_{补}-[B]_{补}=[A]_{补}+M-[B]_{补}$, 而$M-[B]_{补}=[-B]_{补}$, 因此补码可以借助加法运算来实现减法操作

^009f57

>[!note] 变形补码 (模4补码)
>定点数的补码表示, 本质上就是模2补码, 正数部分: $[x]_{补}=(x+2)\%2$
>而模4补码, 就是将模长变为4
>此时符号位就由单符号位变成了双符号位, 同理, 对于定点正数, 将模长变为原来的两倍, 也可以将单符号位变为双符号位
>+ 存储每个模4补码只需要1个符号位

^5c4be2

### 移码表示法

>[!info] 若字长为n+1,  则原码整数的表示范围为$-2^n\leqslant x\leqslant2^n-1$

+ 移码通常用来表示**浮点数的阶码**, 他只能表示整数

>[!info] 移码的特点
>+ 移码中零的表示唯一: 1000
>+ 一个真值的移码和补码仅差一个符号位, $[x]_{补}$的符号位取反即可得$[x]_{移}$
>+ 移码保持了数据原有的大小顺序


# 2.1.3 整数的表示

## 1. 无符号整数的表示

当一个编码的**所有二进位都用来表示数值而没有符号位时, 该编码表示的就是无符号整数**. 此时, 默认数的符号为正, 所以**无符号整数就是正整数或非负整数**. 一般在**全部是正数且不出现负值结果的场合下**, 使用无符号整数
例如, 可用**无符号整数进行地址运算**, 或用来表示指针。通常把无符号整数简单地说成无符号数。
**由于无符号整数省略了一位符号位, 所以在位数相同的情况下, 它能表示的最大整数比带符号整数所能表示的值大**. 例如, 8位无符号整数的形式为00000000-11111111, 对应的数的取值范围为$0-(2^n-1)$, 即最大数为255, 而8位带符号整数的最大数是127

## 2. 有符号整数的表示



# 2.1.4 C语言中整数类型及类型转换

## 1. C语言中的整数数据类型

| 数据类型 | type            | 字节数             |
| ---- | --------------- | --------------- |
| 字符型  | char            | 8               |
| 短整型  | short/short int | 16              |
| 整型   | int             | 32              |
| 长整型  | long/long int   | 16/32 (取决于机器位数) |
+ short/int/long等不指定signed/unsigned时都默认是有符号整数
+ char默认是无符号整数
+ signed/unsigned整型数据都是按**补码形式存储的**

## 2. 有符号和无符号数的转换

机器数相同, 解释方法不同

>[!info] 若同时有无符号数和有符号数参与运算, 则C语言标准规定按无符号数进行运算

## 3. 不同字长整数之间的转换

长字节变量向短字节变量转换时: 高位截断, 低位保留

短字节变量向长字节变量转换时: 高位扩展, 低位复制
+ 若原数字是无符号整数, 进行**零扩展**, 高位部分直接用0填充
+ 若原数字是有符号整数, 进行**符号扩展**, 扩展后的高位部分用原数字的符号位填充