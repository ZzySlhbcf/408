# 3.5.1 程序访问的局部性原理

+ 时间局部性: 最近的未来要用到的信息, 很可能时现在正在使用的信息
+ 空间局部性: 最近的未来要用到的信息, 很可能与现在正在使用的信息在存储空间上是临近的

# 3.5.2 Cache的基本工作原理

为了便于Cache与主存交换信息, Cache和主存都被划分为大小相等的块

Cache块也称Cache行, 块的长度称为块长

Cache的容量远小于主存的容量, 所以**Cache中的块数要远少于主存中的块数**

Cache中仅保存主存中最活跃的若干块的副本, 可按照某种策略预测CPU在未来一段时间内欲访存的数据, 将其装入Cache

>[!note] Cache容量不属于存储系统的容量
>Cache内存的时主存部分块的副本, 不能存储额外信息
>Cache容量=能存放的字数据+地址映射表

![[Cache的基本工作原理.png]]

1. 当CPU发出读请求时: 
  + 若访存地址在Cache中命中(也称Cache命中), 就将此地址转换成Cache地址, 直接对Cache进行读操作, 与主存无关
  + 若Cache不命中, 则仍需访问主存, 并把此字所在的块一次性地从主存调入Cache若此时Cache已满, 则需根据某种替换算法, 用这个块替换Cache中原来的某块信息
  + 整个过程全部由硬件实现
  + **CPU与Cache之间的数据交换以字为单位, 而Cache与主存之间的数据交换则以Cache块为单位**
2. 当CPU发出写请求时: 
  + 若Cache命中, 有可能遇到Cache与主存中的内容不一致的问题, 若Cache命中, 则需要按照一定的写策略处理, 常见的处理方法有全写法和回写法

CPU欲访问的信息已在Cache中的比率称为Cache的命中率
设Cache的总命中次数为$N_{c}$, 访问主存的总次数为$N_{m}$, 则命中率$H$为
$$H=\frac{N_{c}}{(N_{c}+N_{m})}$$
为提高访问效率, 命中率H约接近1越好, 设$t_{c}$为命中时的Cache访存时间, $t_{m}$为主存访问的时间 (未命中时) ,1-H表示未命中率 (缺失率), Cache-主存的平均访问时间$T_{a}$
$$T_{a}=Ht_{c}+(1-H)(t_{c}+t_{m})=t_{c}+(1-H)t_{m}$$

1. 数据查找: 如何快速判断数据是否在Cache中
2. 地址映射: 主存块如何存放在Cache中, 如何将主存地址转换为Cache地址
3. 替换策略: Cache满后, 使用何种策略对Cache块进行替换或淘汰
4. 写入策略: 如何既保证主存块和Cache块的数据一致性, 又尽量提升效率。
# 3.5.3 Cache和主存的映射方式

>[!note] Cache行数比主存块数少得多, 因此主存中只有一部分块的信息可放在Cache中
>Cache中要为每块加一个**标记位**, 指明它是主存中哪一块的副本, 该标记的内容相当于主存中块的编号
>为了说明Cache行中的信息是否有效, 每个Cache行需要一个**有效位**
>Cache行中的信息是主存中某个块的副本, 地址映射是指把主存地址空间映射到Cache地址空间, 即把存放在主存中的信息按照某种规则装入Cache

每个Cache行对应一个标记项(包括有效位、脏位 (一致维护性位)、替换算法位、标记位), 采用组相联方式时, **将每组各行的标记项排成一行, 将各组从上到下排列, 构成一个二维的标记阵列 (地址映射表)**
查找Cache时就是查找标记阵列的标记项是否符合要求

>[!note] 替换算法位
>$$\log_{2}行\quad/\quad\log_{2}组$$

>[!note] Cache的总容量=存储容量+标记位整列容量 (有效位、标记位)

1. 直接映射命中率最低, 全相联命中率最高
2. 直接映射的判断开销最小、所需时间最短; 组相联映射的判断开销最大、所需时间最长
3. 直接映射所占标记位的额外空间开销最小, 全相联映射标记所占额外空间最大

| 映射方式  | 标记                      | Cache行号/组号  | 块内地址              |
| ----- | ----------------------- | ----------- | ----------------- |
| 直接映射  | 主存位数-$\log_{2}行$-块内地址位数 | $\log_{2}行$ | $\log_{2}主存地址字节数$ |
| 组相联映射 | 主存位数-$\log_{2}组$-块内地址位数 | $\log_{2}组$ | $\log_{2}主存地址字节数$ |
| 全相联映射 | 6bit                    |             | $\log_{2}主存地址字节数$ |


## 直接映射

主存中的每一块只能装入Cache中的唯一位置. 若这个位置已有内容, 则产生块冲突，原来的块将**无条件**地被替换出去(无须使用替换算法)
直接映射实现简单, 但不够灵活, 即使Cache的其他许多地址空着也不能占用, 这使得直接映射的**块冲突概率最高, 空间利用率最低**

Cache行号=主存块号 mod Cache总行数
主存块号的低c位是它要装入的Cache的行号

给Cache行设置一个长为t=m-c的标记, 当主存块调入Cache后, 将其块号的高t位设置在标记中

![[Cache和主存之间的直接映射方式.png]]

CPU先根据访存地址的中间c位, 找到Cache行, 对高t位进行比较
## 全相联映射

**主存中的每一块可以装入Cache中的任何位置**
1. Cache块的冲突概率低，只要有空闲Cache行，就不会发生冲突
2. 空间利用率高
3. 命中率高
4. 标记的比较速度较慢
5. 实现成本较高, 通常需采用**按内容寻址的相联存储器**

![[Cache和主存之间的全相联映射方式.png]]

为每一个Cache行都设置一个比较器, 比较器的位数等于标记字段的位数, 访存时, 根据标记字段的内容来访问Cache行中的主存块
查找过程是一种"**按内容访问**"的存取方式

![[组相联标记阵列.png]]
## 组相联映射

将Cache分为Q个大小相等的组, 组间采用直接映射, 组内采用全相联

![[Cache和主存之间的组相联映射方式.png]]

Cache组号=主存块号 mod Cache组数Q

>[!note] 直接映射因为每块只能映射唯一的Cache行, 因此只需设置1个比较器, 而r路组相联映射需要在对应分组中与r个Cache行进行比较, 需要设置r个比较器
# 3.5.4 Cache中主存块的替换算法

1. 随机算法 (RAND): 随机地确定替换地Cache行, 没有依据程序访问的局部性原理
2. 先进先出算法 (FIFO): 选择最早调入的Cache行进行替换, 没有依据程序访问的局部性原理
3. 近期最少使用算法 (LRU): 依据程序访问的局部性原理, 选择近期内长久未访问的Cahce行进行替换, 是堆栈类算法
4. 最不经常使用算法 (LFU): 将一段时间内被访问次数最少的Cache行换出. 每行也设置一个计数器

>[!info] LRU算法
>LRU算法对每个Cache行设置一个计数器 (也称LRU替换位), 用计数值来记录主存块的使用情况, 并根据计数值选择淘汰某个块, **计数值的位数与Cache组大小有关**, 2路时有1位LRU位, 4路时有2位LRU位
>![[LRU算法的替换过程示意图.png]]
>1. 命中时, 所命中的行计数器清零, 比起低的计数器+1, 其余不变
>2. 未命中且还有空闲行时, 新装入的行计数器置0, 其余非空闲行全+1
>3. 未命中且无空闲行时, 计数值为3的行信息块被替换, 新装入的行的计数器置0, 其余全+1
>   
>**当集中访问的存储区超过Cache组的大小时**, 命中率可能变得很低, 这种现象被称为抖动



# 3.5.5 Cache的一致性问题

全写法和回写法都对应于Cache写命中 (要被修改的块在Cache中)时的情况。
对于Cache**写操作不命中**，也有两种处理方法。
+ 写分配法 (WriteAllocate): 更新主存单元, 然后把这个主存块调入Cache
  试图利用程序的空间局部性, 缺点是**每次写不命中都要从主存读一个块到Cache中**
+ 非写分配法 (Not-Write-Allocate): 只更新主存单元, 而不把主存块调入Cache

>[!note] 非写分配法通常与全写法合用，写分配法通常和回写法合用

|     | 命中时 | 未命中时  | 需要   |
| --- | --- | ----- | ---- |
| 方法一 | 全写法 | 非写分配法 | 写缓冲  |
| 方法二 | 回写法 | 写分配法  | 设置脏位 |

随着指令流水技术的发展, 需要将指令Cache和数据Cache分开设计, 这就有了分离的Cache结构
+ 统一Cache的优点是设计和实现相对简单, 但由于**执行部件存取数据时, 指令预取部件要从同一Cache读指令, 会引发冲突**
+ 采用分离的Cache结构可以解决这个问题, 而且**分离的指令和数据Cache还可以充分利用指令和数据的不同局部性来优化性能**

>[!note] 指令Cache有更好的空间局部性 (指令通常顺序执行, 而数据跳转访问的概率高)

**现代计算机的Cache通常设立多级Cache**, 假定设2级Cache，按离CPU的远近可各自命名为L1Cache、L2Cache, **离CPU越远, 访问速度越慢, 容量越大**

指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与回写法合用
L1Cache对L2Cache使用全写法，L2Cache对主存使用回写法, 由于L2Cache的存在，其访问速度大于主存, 所以避免了因频繁写时造成的写缓冲饱和溢出

![[两级Cache系统.png]]

## 全写法

当CPU对Cache写命中时, 必须把数据同时写入Cache和主存. 当某一块需要替换时, 就不必把这一块写回主存了, 用新调入的块直接覆盖即可
这种方法实现简单, 能随时保持主存数据的正确性
缺点是增加了访存次数, 降低了Cache的效率

写缓冲: 为减少全写法直接写入主存的时间损耗, 在Cache和主存之间加一个写缓冲 (WriteBuffer), **CPU同时写数据到Cache和写缓冲中**, 写缓冲再将内容写入主存
写缓冲是一个FIFO队列, 写缓冲可以解决速度不匹配的问题. 但若出现频繁写时，会使写缓冲饱和溢出

## 回写法

当CPU对Cache写命中时, 只把数据写入Cache, 而不立即写入主存, 只有当此块被替换出时才写回主存
这种方法减少了访存次数, 但存在数据不一致的隐患

为了减少写回主存的次数, 给每个Cache行设置一个修改位 (脏位): 若修
改位为1, 则说明对应Cache行中的块被修改过, 替换时须写回主存; 若修改位为0，则说明对应Cache行中的块未被修改过，替换时无须写回主存



