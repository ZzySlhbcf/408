
+ 结点的度: 结点拥有的子树的数量, 树中所有结点的度数的最大值为数的度
+ 度为0: 叶子结点或者终端结点
+ 度不为0: 分支结点或者非终端结点
+ 祖先结点: 根结点到该结点的唯一路径上最接近该结点的结点
+ 兄弟结点: 有共同双亲结点的结点
+ 层次: 根为第一层, 它的孩子为第二层, 以此类推
+ 结点的深度: 根结点开始自顶而下累加
+ 节点的高度: 叶结点开始自底而上累加
+ 树的高度 (深度): 树中结点的最大层数
+ 总节点数: 总度数 (边数) +1
+ 总度数: 每个结点度数之和

>[!info] 
>高度为h的m叉数至少有h个结点, 至多有$\frac{m^h-1}{m-1}$个结点 (等比数列求和)

# 二叉树

1. 非空二叉树上叶子结点数等于度为2的结点数加1即: $n_{0}=n_{2}+1$
2. 非空二叉树上第k层上至多有$2^{k-1}$个结点
3. 高度为H的二叉树至多有$2^H-1$个结点
4. 具有N个结点的完全二叉树的高度为$l\lceil \log_{2}(N+1) \rceil$或$\lfloor \log_{2}N \rfloor+1$

```c++
typedef struct Node{
	int data;
	Node *left,*right;
	Node *parent;
}Node;
```
## 二叉树的遍历

### 二叉树的先序遍历

```c++
void preOrder(Node* root){
	if(!root) return;
	visit(root);
	preOrder(root->left);
	preOrder(root->right)
}
```

### 二叉树的层序遍历 (BFS)

```c++
void levelOrder(Node* root)
	if(!root) return;
	Queque<Node*> q;
	q.push(root);
	while(!q.empty()){
		Node* node=Q.top();
		q.pop();
		if (node->left) q.push(node->left);
		if (node->right) q.push(node->right);
	};
```

## 满二叉树

对于编号为i的结点
1. 双清为$\left\lfloor  \frac{i}{2}  \right\rfloor$
2. 若有左孩子, 则左孩子为2i
3. 若有右孩子, 则右孩子为2i+1

## 完全二叉树

## 线索二叉树

> 将结点的空指针指向其前驱或者后继
> + 方便找到前驱和后继; 遍历可以不从结点开始
> + 后序线索二叉树不能有效求后序后继

```c++
typedef struct Node{
	int data;
	Node *left,*right;
	bool ltag,rtag; //true表示线索, false表示孩子
}Node;
```

# 树、森林和二叉树的转换


| 树    | 森林   | 二叉树  |
| ---- | ---- | ---- |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |


## 树转换为二叉树

1. 加线: 在兄弟之间架一条线
2. 抹除: 对每个结点, 除了左孩子外, 去除与其余孩子之间的关系
3. 旋转: 以树的根结点为轴心, 将树顺时针旋转45度

## 二叉树转换为树

1. 加线: 若p结点是双亲结点的左孩子, 则将p的右孩子, 右孩子的右孩子……沿分支找到的所有右孩子, 都与p的双亲连起来
2. 抹线: 抹掉原二叉树中双亲与右孩子之间的连线
3. 调整: 将结点按层次排序, 形成树结 构

# 哈夫曼树

> 每次从合成后存在的结点中选出两个权最小的进行构造二叉树, 直到所有结点均在树中

>[!important] 哈夫曼树没有度为1的结点

## 哈夫曼编码

> 对频率高的字符赋以短编码, 对频率较低的字符赋以较长一些的编码, 起到压缩效果

前缀编码: 没有一个编码是另一个编码的前缀
1. 将每个出现的字符当作一个独立的结点, 其权值为它出现的频度 (或i次数), 构造出对应的哈夫曼树
2. 将字符的编码解释为从根至该字符的路径上边标记的序列
3. 其中边标记为0表示"转向左孩子", 标记为1表示"转向右孩子"