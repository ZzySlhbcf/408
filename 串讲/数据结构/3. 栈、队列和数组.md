# 栈

> 只允许在一段进行插入或删除操作的线性表

>[!info] 特点
>1. 栈是受限的线性表, 所以自然具有线性关系
>2. 栈中元素后进入必然先出来, 即后进先出LIFO
>3. n个不同元素进栈, 出栈元素不同排序个数为 (n个元素能构成多少种二叉树)
>$$
>\frac{1}{n+1}C^n_{2n}
>$$

## 顺序栈

```c++
typedef struct{
	int data[MaxSzie];
	int top;//栈顶指针
}Stack;
```

>[!info] 栈的操作
>1. 判空: empty()
>2. 进栈: push(int data)
>3. 出栈: pop()
>4. 读取栈顶元素: top()

## 共享栈

>[!info] 栈的操作
>1. 进栈: push(Stack &s,int data,int stack_no)

栈满条件: 指针top1和top2只相差1, 即top1+1=top2

## 链式栈

```c++
typedef struct Node{
	Node* next;
	int data;
}Node;

typedef struct{
	Node* top; //头指针
	int size;
}Stack;
```

# 队列

+ 队头: 允许删除的一端, 又称为队首
+ 队尾: 允许插入的一端

## 顺序队列

```c++
typedef struct{
	int data[MaxSize];
	int front,rear;
}Queue;
```
## 循环队列

+ 入队: rear=(rear+1)%MaxSize
+ 出队: front=(front+1)%MaxSize

>[!info] 队满判断
>1. 牺牲一个单元, 即队头指针在队尾指针的下一个位置作为队满标志
>   队满条件: (Q.rear+1)%MaxSize\==Q.front
>2. 类型中增加表示元素个数的数据元素 (int Size)
>3. tag\==0时, 若因删除导致Q.front\==Q.rear, 则队空; tag\==1时, 若因插入导致Q.front\==Q,rear, 则队满

## 链式队列

```c++
typedef struct Node{
	Node* next;
	int data;
}Node;

typedef struct{
	Node *front,*rear;
}Queue;
```

>[!info] 链式队列的实现
>能否在O(1)获取到头尾指针: 有尾指针的循环单链表、有头指针的循环双链表

## 双端链表

输入受限的双端队列、输出受限的双端队列

# 栈和队列的应用

## 括号匹配

1. 若是左括号, 入栈
2. 若是右括号, 出栈一个左括号判断是否与之匹配
3. 检验字符串尾, 还要检查栈是否为空
4. 只有栈空, 整个字符串才括号匹配

## 中缀表达式

# 数组和压缩矩阵



