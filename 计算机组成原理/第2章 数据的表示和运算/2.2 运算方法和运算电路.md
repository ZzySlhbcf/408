# 2.2.1 基本运算部件

![[时序逻辑电路和组合逻辑电路.png]]

运算器由算数逻辑单元(ALU)、位移器、状态寄存器(PSW)和通用寄存器
ALU的核心部件是加法器

运算器的核心部件是ALU, ALU提供**算术运算和逻辑运算**, 其中, 算术运算用于执行数学操作, 包括加法、减法、乘法、除法, 逻辑运算用于判断条件真假 (true/false或0/1), 包括逻辑与, 逻辑或等
另外, 还包括累加器、状态寄存器(标志寄存器) 、通用寄存器等
+ 累加器 (AC)：累加器暂存源操作数和运算结果
+ 状态寄存器 (PSW)：状态寄存器保存状态标志和控制标志, 如进位标志、溢出标志等
+ 通用寄存器组：通用寄存器用于暂存数据, 供运算器进行操作

## 一位全加器

![[一位全加器.png]]

+ 和表达式: $S_{i}=A_{i}\oplus B_{i}\oplus C_{i-1}$ (当$A_{i}$、$B_{i}$、$C_{i-1}$有奇数个1时, $S_{i}=1$, 否则$S_{i}=0$)
+ 进位表达式: $C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}$

## 串行进位加法器

![[n位串行进位加法器.png]]

在串行进位加法器中, 低位运算产生进位所需的时间将影响高位运算的时间, **串行加法器的最长运算时间主要是由进位信号传递时间决定的**

## 并行进位加法器\*

![[并行进位加法器.png]]

构造一个n位并行进位加法器, 需要将n个一位全加器连接上n位先行进位部分 (简称CLA部件), 其作用是"并行产生进位"
## 带标志加法器

![[带标志加法器.png]]

+ 溢出标志: $OF=C_n\oplus C_{n-1}$, 用于判断**有符号数**加减运算是否溢出, OF=1表示溢出
+ 符号标志: $SF=F_{n-1}$, 有符号数加减运算的正负性, SF=1表示负
+ 零标志: $ZF=1$当且仅当$F=0$, 加减运算是否为0, ZF=1表示结果为0
+ 进位/借位标志: $CF=C_{out}\oplus C_{in}$, 用于判断**无符号数**的加减运算是否发生溢出, CF=1表示溢出
## 算数逻辑单元

![[算术逻辑单元ALU.png]]

ALU的核心是带标志加法器, 同时也能执行逻辑运算

ALUop是操作控制端, 用来决定ALU所执行的处理功能, ALUop的位数决定了操作的种类: 当位数为3时, ALU最多有8种操作

ALU也可以实现左移或右移的移位操作
# 2.2.2 定点数的位移运算

>[!info] 左移的溢出判断
>**表达式x<<k表示对数x左移k位**. 对于左移来说，**逻辑移位和算术移位的结果都一样, 都是丢弃k个最高位, 并在低位补k个0. 每左移一位, 相当于数值扩大一倍**, 所以左移可能会发生溢出, **左移k位, 相当于数值乘以$2^k$**
>对于**无符号数的逻辑左移, 若高位的1被移出, 则会发生溢出**. 例如, 寄存器的内容为10001110, 逻辑左移1位为00011100，对于无符号数来说发生溢出
>对于**有符号数的算术左移**, 若移出的高位不同于移位后的符号位, **即左移前后的符号位不同，则发生溢出**
>例如, 补码1001和0101左移时会发生溢出

## 逻辑位移

逻辑位移将操作数视为无符号整数, **不考虑符号位, 一般用于无符号数的位移**
+ 逻辑左移时, 低位补0, 高位移出
+ 逻辑右移时, 高位补0, 低位移出

## 算数位移

算术移位需要考虑符号位的问题, 一般用于有符号数的移位
计算机中的有符号整数都是用补码表示的, 因此对于有符号整数的移位操作应采用补码算术移位方式
+ 算术左移时, 低位补0, 高位移出
+ 算术右移时, 高位补符号位, 低位移出

# 2.2.3 定点数的加减运算

## 补码的加减法运算

## 溢出判断方法

>[!info] 只有同号相加/异号相减 才有可能发生溢出

### 采用一位符号位

参加操作的两个数符号相同, 结果数的符号位与操作数的符号不同, 则结果溢出
### 采用双符号位

双符号位的补码也称[[2.1 数制和编码#^5c4be2|模4补码]]. 假设两个数分别为A和B, 首先把A、B补成双符号位. 具体来说, 若A、B均为正数, 则均在符号位前补一个O; 若A、B均为负数，则均在符号位前补一个1
例如, A=1001, B=1010, 则双符号位下, A=11.001, B=11.010. 倘若运算结果的两个符号位$S_{s1}S_{s2}$相同，表示未溢出; 运算结果的两个符号位$S_{s1}S_{s2}$不同, 表示溢出

1. $S_{s1}S_{s2}=00$: 结果为正数, 无溢出
2. $S_{s1}S_{s2}=01$: 结果正溢出
3. $S_{s1}S_{s2}=10$: 结果负溢出
4. $S_{s1}S_{s2}=11$: 结果为负数, 无溢出

### 采用一位符号位根据数值位的进位情况判断溢出

若符号位 (最高位) 的进位与最高数位 (次高位) 的进位相同, 则说明没有溢出, 否则表示发生溢出. 
假设符号位的进位为$C_{1}$, 最高数位的进位为$C_{2}$, 若OF=1表示溢出, 则逻辑表达式为$OF=C_{1}\oplus C_{2}$, 其中OF的意思是Overflow Flag, 即溢出标志

## 加减运算电路

+ **若Sub=0, 表示做加法操作, 选择多路选择器的第一路信号作为输出**, 即让B通过, 此时$C_{in}=0$
  接着加法器会做加法操作, 计算$A+B+C_{in}$, 并更新标志位
+ **若Sub=1, 表示做减法操作, 选择多路选择器的第二路信号作为输出**, 即让-B通过, 此时$C_{in}=1$
  这里**对B做了变补操作, 即 (包含符号位) 按位取反, 末位加1, 本质上是利用了补码运算规则**: $[A-B]_补=[A]_{补}+[-B]_{补}(\mod 2^{n+1})$ [[2.1 数制和编码#^009f57|模运算]]
  接着加法器会做加法操作, 计算$A+(-B)+C_{in}$, 并更新标志位

>[!attention] 若Sub=1, 减数只需要除符号位按位取反即可, 输入后加法器后, 会Sub=1会作为Cin=加到减数上, 相当于按位取反再+1


![[加减运算电路.png]]

另外, **该电路对于无符号整数加减法和有符号加减法是通用的**. **在实际运算的机器层面, 所有参与运算的数和获得的结果只是一串二进制0/1序列, 机器并不区分机器数是什么类型**, 都是按照同样的规进行运算
**对于同一个机器数, 高级语言的编译器会根据数据类型对应的编码方式对机器数进行相应的解释**. 例如, 同样是变量A, 若A是int类型, 则编译器按照补码解释其机器数, 若A是unsigned int类型, 则编译器按照无符号数方式解释其机器数

### 无符号数大小的比较

1. 当ZF=1时, 说明A=B
2. 当ZF=0且CF=0时, 说明A>B
3. 当CF=1时, 说明A\<B

### 有符号数大小的比较

1. 当ZF=1时, 说明A=B
2. 当ZF=0且未发生溢出时, 即OF=0时, 若SF=0, 则表示结果非负, 说明A>B
3. 当发生溢出时, 即OF=1, 若SF=1, 则必然时正数减去负数发生溢出导致结果为负
   因此, 当OF=SF (或$OF\oplus SF=0$), 且ZF=0时, 说明A>B
4. 当ZF=0且未发生溢出时, 即OF=0时, 若SF=1, 则表示结果为负, 说明A\<B
5. 当发生溢出时, OF=1时, 若SF=0, 则必然时负数减去正数发生溢出导致结果为正
   因此, 当OF!=SF (或$OF\oplus SF=1$), 且ZF=0时, 说明A\<B



# 2.2.4 定点数的乘除运算

## 定点乘法运算

### 乘法运算的基本原理

用原码实现乘法运算时, 符号位与数值位分开计算:
1. 确定乘积的符号位, 由两个乘数的符号异或得到 (符号位不参与运算)
2. 计算乘积的数值位. 乘积的数值部分分为两个乘数的数值部分之积 

>[!attention] 由于参与运算的是两个数值位, 因此运算过程中右移操作均为逻辑右移
### 乘法运算电路

## 除法运算

### 除法运算的基本原理

### 除法运算电路