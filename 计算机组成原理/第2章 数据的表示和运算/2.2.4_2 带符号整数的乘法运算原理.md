> "补码一位乘法"也称布斯（Booth）乘法
## 电路区别
+ ALU可能进行加、减
+ 低位增加一个“辅助位”
+ 控制逻辑根据2bit（Y的最低位、辅助位）决定本轮该如何处理
+ 不保存最高位的进位信息
初始化：
1. 将被乘数、乘数分别放入寄存器X、Y中
2. 乘积寄存器P 置为0，“辅助位”置为0
3. 计数器$C_n$的初始值置为n（n为乘数的位数）
**特殊情况**：当被乘数、乘数中有一个为全0时，结果直接得0，不需要再进行后续的运算步骤

重复n轮加法/减法、位移运算，直到计数器$C_n=0$：
1. 将乘数寄存器Y的最低位、辅助位，2bit送入“控制逻辑”进行判断
2. 根据寄存器Y的最低位、辅助位，决定是$+[x]_补$ $+[x]_补$ +0
3. 将\[P,Y,辅助位]视为整体，**算数右移**一位
4. 计数器$C_n$减1

| 寄存器Y最低位 | 辅助位 | 本轮操作     |
| ------- | --- | -------- |
| 0       | 0   | +0       |
| 0       | 1   | $+[x]_补$ |
| 1       | 0   | $-[x]_补$ |
| 1       | 1   | +0       |

结束（计数器$C_n=0$）：
1. 乘法运算的结果用2n位暂存（寄存器P、寄存器Y）
2. 在很多计算机框架中，通常仅保留n位作为乘积结果（因此，运算结果可能发生溢出）

溢出判断：
+ 若**高n+1位**不完全相同，说明发生溢出，此时可将OF标志位置1
溢出处理：
+ 忽略“溢出”
+ 在乘法指令之后执行一条**溢出自陷指令**。该指令会检查OF标志位。若OF=1，则执行系统的“异常处理程序”