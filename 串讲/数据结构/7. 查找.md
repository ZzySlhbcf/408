
平均查找长度: $ASL=\sum^n_{i=1}p_{i}c_{i}$

# 顺序查找和折半查找

## 二分查找

```c++
int binarySearch(int A[],int len,int target){
	int low=0,high=len-1;
	while(low<=high){
		int mid=(low+high)/2;
		if(A[mid]==target) return mid;
		if(A[mid]<tatget) low=mid;
		else high=mid;
	}
	return -1
}
```

## 分块查找

# 树形查找

## 二叉搜索树

+ 二叉排序树: 左子树结点值 (若左子树非空)<根结点值<右子树结点值 (若右子树非空), 其左右子树又各是一棵二叉排序树
+ 中序遍历非空的二叉排序树所得的数据元素是一个按关键字排序的递增有序序列
+ 插入: 若关键字小于根结点值, 插入左子树, 若关键字大于根结点值, 插入右子树
+ 删除:
  1. 若被删除的结点是叶结点, 直接删除
  2. 若结点只有一颗左子树或右子树, 让子树成为该结点的父节点的子树, 代替该结点
  3. 若结点有左右两棵子树
+ 平均查找长度ASL=查找树每层节点个数\*对应深度之和

## 平衡二叉树

> 平衡二叉树是二叉排序树, 且左子树与右子树的高度之差的绝对值小于等于1, 左子树和右子树也是平衡二叉树

+ 平衡因子: 结点左子树的高度-结点右子树的高度
+ 调整: 当平衡二叉树插入 (删除) 一个结点时, 首先检查其插入路径上的结点是否因此次操作导致不平衡, 若不止一个失衡结点时, 从最小失衡子树的根结点开始平衡, 直到所有结点都满足平衡二叉树特性, 根据操作位置分为: LL右单旋、RR左单旋、LR先左旋后右旋转、RL先右后左旋转

原则1: 降低高度
原则2: 找出3个结点, 保持二叉排序树的性质

## 红黑树

>+ 根节点是黑色的 (每个结点不是黑就是红)
>+ 叶结点 (外部结点/NULL结点/失败结点)均是黑色
>+ 不存在两个相邻的红结点 (即红结点的父结点和孩子结点均是黑色)
>+ 对每个结点, 从该结点到任意叶结点的简单路径上, 所含黑结点的数目不同

性质: 根到叶结点最长路径小于等于最短路径 (全黑) 2倍, n个结点高度$h\leqslant{2}\log_{2}(n+1)$

黑高: 从某结点出发 (不包含该结点) 到达任一空结点上黑色结点数
若根结点黑高为h, 内部结点数 (关键字) 最少有$2^h-1$个

# B树和B+树

## B 树

> 多路平衡查找树 (所有结点的平衡因子均为0), B树中所有结点的孩子个数的最大值称为B树的阶, 用m表示

+ 树中每个结点至多有m棵子树, 至多有m-1个关键字
+ 关键字个数: $\lceil m/2 \rceil-1\leqslant n\leqslant m-1$ (根结点: 1<=n<=m-1)
+ 子树个数: $\lceil m/2 \rceil\leqslant n\leqslant m$ (根结点: $2\leqslant n \leqslant m$)
+ 所有的叶结点 (失败结点)都出现在同一层次上, 且不带信息

B树的高度 (磁盘存取次数): 对任意一颗包含n个关键字、高度为h、阶数为m的B树, $h>\log_{m}(n+1)$

### B树的查找

### B树的插入

### B树的删除

## B+树

# 散列查找

