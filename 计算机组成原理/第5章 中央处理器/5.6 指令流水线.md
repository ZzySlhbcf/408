# 5.6.1 指令流水线的基本概念

+ 时间上的并行技术: 将一个任务分解为几个不同子阶段, 每个子阶段在不同的功能部件上并行执行
+ 空间上的并行技术: 在一个处理机内设置多个执行相同任务的功能部件, 这样的处理机称为**超标量处理机**

1. 取指(IF): 从指令存储器或Cache中取指令
2. 译码/读寄存器(ID): 操作控制器对指令进行译码:, 同时从寄存器堆中取操作数
3. 执行/计算地址(EX): 执行运算操作或计算地址
4. 访存(MEM): 对存储器进行读/写操作
5. 写回(WB): 将指令执行结果写回寄存器堆

![[5段指令流水线.png]]

>[!info] 为了利于实现指令流水线, 指令集应具有的特征
>1. **指令长度应尽量一致**, 有利于简化取指令和指令译码操作
>   取指令所花的时间长短不一, 使得取指部件极其复杂, 并且也不利于指令译码
>2. **指令格式应尽量规整**, 尽量保证源寄存器的位置相同, 有利于在指令未知时就可取寄存器操作数, 否则须译码后才能确定指令中各寄存器编号的位置
>3. **采用LOAD/STORE型指令, 其他指令都不能访问存储器**
>   这样可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中, 有利于减少操作步骤
>4. **数据和指令在存储器中“按边界对齐”存放**
>   有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。

# 5.6.2 指令流水线的基本实现

## 流水线设计的原则

1. 指令流水段个数以最复杂指令所用的功能段个数为准
2. 流水段的长度以最复杂的操作所花的时间为准
   
假设某条指令的5个阶段所花的时间分别如下:
①取指: 200ps; ②译码: 100ps; ③执行: 150ps; ④访存: 200ps; 写回: 100ps, 该指令的总执行时间为750ps

按照流水线设计原则, 每个流水段的长度为200ps, 所以每条指令的执行时间为1ns, 反而比串行执行时增加了250ps
假设某程序有N条指令, 单周期处理机所用的时间为N×750ps, 而流水线处理机所用的时间为(N+4)×200ps。

>[!important] 流水线方式并不能缩短单条指令的执行时间, 但对于整个程序来说，执行效率得到了大幅提高

## 流水线的逻辑结构

每个流水段后面都要增加一个流水段寄存器, 用于锁存本段处理完的所有数据

![[流水段逻辑结构图.png]]

## 流水线的时空图表示

![[5段指令流水线的时空图.png]]

# 5.6.3 指令流水线的冒险与处理

> 在指令流水中, 可能遇到一些情况使得后续指令无法正常执行引起流水线阻塞

![[不同类型指令在各流水段中的作用.png]]

## 结构冒险

> 不同指令在同一时间争用统一部件而形成的冲突, 也称资源冲突

>[!info] 解决结构冲突有以下两种办法
>1. 前一指令访存时, 使后一指令暂停一个时钟周期
>2. 设置多个独立的部件, 例如将寄存器的读口和写口独立开来; 这只数据存储器和指令存储器

## 数据冒险

> 后面指令用到前面指令的结果时, 前面指令的结果还没有产生
> 这种数据冒险称为写后读 (RAW冲突)

>[!info] 解决RAW冲突有以下几种办法
>1. 延迟执行相关命令: 把数据相关的指令及其后续指令都暂停一至几个时钟周期, 直到数据相关问题消失后再继续执行
>   可分为软件插入空操作"nop"指令和硬阻塞两种办法
>2. 转发(旁路技术): 设置相关转发通路, 不等前一条指令把计算结果写回寄存器, 下一条指令也不再从寄存器读
>3. load-use数据冒险处理: 
## 控制冒险



# 5.6.4 指令流水线的性能指标

## 流水线的吞吐率

## 流水线的加速比

# 5.6.5 高级指令流水线

## 超标量流水线技术

## 超长流水线技术

## 超流水线技术



