
+ 连通图 (强连通图): 在无(有)向图中, 若对任何顶点v, u都存在从从v到u的路径, 则G是连通图(强连通图) (任意两个结点之间都有路径)
+ 连通分量/极大连通子图: 该子图是G连通子图, 将G的任何不在该子图的顶点加入, 子图不再强联通
+ 极小联通子图: 该子图是G的连通子图, 在该子图中删除任何一条边, 子图不再连通
+ 生成树: 包含无向图G所有顶点的极小连通子图
+ 生成森林: 对非连通图, 由各个连通分量的生成树的集合

![[图.png]]

# 图的存储

## 邻接矩阵

> 用一个一位数存储图中的顶点信息, 用一个二维数组存储图中边的信息

```c++
typedef struct{
	int edges[MaxSize][MaxSize];
	char vertices[MaxSize];
	int edge_num,vertice_num;
}Graph;
```
>[!info] 邻接矩阵不是对称矩阵说明是有向图
## 邻接表

> 顶点用一个一维数组存储, 元素包含指向第一个邻接点的指针, 存储顶点和头指针的一维数组叫顶点表, 每个顶点的所有邻接点构成一个单链表

```c++
typedef struct Arc{
	Arc* next;
	int vertice_no;
	int weight; //权值,可选
}Arc;
typedef struct{
	int data;
	Arc* firstArc; //该顶点所连边链表的头结点
}Vertice;
typedef struct{
	Vertice vertice[MaxSize];
	int Vertice_num,arc_num;
}
```

# 图的遍历

## DFS

# 最小生成树

> 生成树: 所有顶点均由边连接在一起, 但不存在回路的图
> 最小生成树: 权值之和最小的那棵生成树, 不唯一, 但是权值和唯一且最小, 边数=顶点数-1

## Prim算法

> 每次将代价最小的新顶点加入生成树

1. 开始时从图中任取一个顶点加入树T
2. 之后选择一个与当前T中顶点集合距离最近的顶点, 将该点和对应边加入T, 每次操作后T中顶点数和边数都+1
3. 以此类推, 当所有点加入T, 必然由n-1条边, 即T就是最小生成树

+ 时间复杂度: O(|V|^2)
+ 适用范围: 稠密图

## Kruskal算法

>每次选一条权值最小的边 (边按权值排序), 使其连通 (用**并查集**判断实现)

1. 开始时为只有n个顶点而无边的非连通图T={V,{}}, 每个顶点自成一个连通分量
2. 然后按照边的权值由小到大, 不断选取当前未被选取过且权值最小的边
3. 以此类推, 直到T中所有顶点都在一个连通分量上

+ 时间复杂度: O(|E|log|E|)
+ 适用范围: 稀疏图

# 最短路径

## Dijkstra算法

> 维护一个最短路径数组, 每次选取最短的顶点加入, 更新1加入后的最短路径

1. 初始化: 集合S初始化为{0}, dist\[]初始化值dist\[i]=arcs\[0]\[1] (与原点距离)
2. 从顶点集合V-S中选取dist\[]数组值最小的, 即选最近的点加入
3. 修改V0出发到集合V-S上任一顶点最短路径长度, 若dist\[j]+arcs\[j]\[k]\<dist\[k], 则更新dist\[k]=dist\[j]+arcs\[j]\[k]
4. 重复步骤2-3n-1次, 直到所有顶点都包含在S中

## Floyd算法

> 维护一个各顶点间最短路径**二维数组**, 不断试探加入中间结点, 是否缩短距离 (三重循环)
> + 允许图中有带负权值的边, 但不允许有包含带负权值的边组成贿赂

1. 初始化: 对任意两个顶点vi和vj, 若存在边, 则二维数组上最短路径为权值 (不存在则最短路径为无穷)
2. 逐步尝试在原路径上加入顶点k(k=0,1,……,n-1)为中间结点
3. 若更新后得到路径比原本路径长度短, 则新路径代替原本路径

# 有向无环图描述表达式

# 拓扑排序

# 关键路径

+ 关键路径: 从源点到汇点的所有路径中具有最大路径长度的路径
+ 关键活动: 关键路径上的活动

+ 事件最早发生事件$V_{e}()$
+ 事件最迟发生时间$V_{l}()$
+ 活动最早发生事件$e()$
+ 活动最迟发生事件$l()$
+ 活动的事件余量$d()$