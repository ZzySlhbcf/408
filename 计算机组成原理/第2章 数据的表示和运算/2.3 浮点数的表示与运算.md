# 2.3.1 浮点数的表示

## 浮点数的表示格式

![[32位浮点数格式.png]]

+ 0为符号S
+ 1-7为移码表示的阶码E (偏置值为64): 阶码的值反映浮点数的小数点的实际位置; 阶码的位数表示浮点数的表示范围
+ 8-31为24位二进制**原码小数**表示的尾数M: 尾数的位数表示浮点数的精度
+ 基数R为2
## 浮点数的表示范围

![[浮点数的表示范围.png]]

运算结果大于最大正数时称为**正上溢**, 小于绝对值最大负数称为**负上溢**: 数据一旦出现上溢, 计算机必须中断运算操作, 进行溢出处理
运算结果在0至最小正数之间称为**正下溢**, 在0至绝对值最小负数之间称为**负下溢**: 数据下溢时, 浮点值趋于零, 计算机将其当作0处理

## 浮点数的规格化

> 调整一个非规格化浮点数的尾数和阶码大小, 使非浮点数在尾数的最高位上保证是一个有效值
> 规格化浮点数主要是为了**增加数据的表示精度**

+ 左规: 当运算结果的尾数不是有效位, 即出现$\pm0.0\dots \times\dots\times$的形式时, 需要进行左规
  左规时, 尾数每左移一位、阶码减1
+ 右规: 当运算结果的尾数的有效位进到小数点前面, 需要进行右规
  将尾数右移一位、阶码加1

>[!attention] 规格化可能导致阶码溢出
>右规时, 阶码增加可能导致上溢
>左规时, 阶码减小可能导致下溢


基数为2的**原码**规格化尾数M应满足$1/2\leqslant|M|<1$
1. 正数为$0.1\times\dots\times$, 最大值为$0.11\dots{1}$, 最小值为$1.100\dots{0}$, 表示范围为$1/2\leqslant|M|\leqslant(1-2^{-n})$ 
2. 正数为$1.1\times\dots\times$, 最大值为$1.10\dots{0}$, 最小值为$1.11\dots{1}$, 表示范围为$-(1-2^{-n})\leqslant|M|\leqslant-1/2$

>[!info] 基数不同, 浮点数的规格化形式也不同
>+ 当浮点数尾数的基数为2时, 原码规格化的尾数最高位一定是1
>+ **当基数为4时, 原码规格化数的尾数最高两位位不全为0**


## IEEE 754 标准

![[IEEE754标准浮点数的格式.png]]

+ 尾数的最高位总是1, 为了能使尾数多一位有效位, 将这个1隐藏, 称为**隐藏位**
+ IEEE754规定隐藏位1的位置在小数点之前
+ 偏置值是$2^{n-1}-1$, 单精度和双精度浮点数的偏置值分别位127和1023
+ 规格化单精度浮点数的真值为: $(-1)^s\times 1.f\times2^{e-127}\quad e\in[1,254]$
+ 规格化双精度浮点数的真值为: $(-1)^s\times 1.f\times2^{e-1023}\quad e\in[1,2046]$

| 格式  | 最小值                                            | 最大值                                                                                    |
| --- | ---------------------------------------------- | -------------------------------------------------------------------------------------- |
| 单精度 | $e=1, f=0$<br>$1.0\times 2^{1-127}=2^{-126}$   | $e=254, f=.111\dots$<br>$1.111\dots{1}\times 2^{254-127}=2^{127}\times(2-2^{-23})$     |
| 双精度 | $e=1, f=0$<br>$1.0\times 2^{1-1023}=2^{-1022}$ | $e=2046, f=.111\dots$<br>$1.111\dots{1}\times 2^{2046-1023}=2^{1023}\times(2-2^{-52})$ |

![[IEEE754浮点数的解释.png]]

1. 全0阶码全0尾数: $\pm  {0}$, 0的符号取决于s
2. 全1阶码全0尾数: $\pm\infty$
3. 全1阶码非0尾数: NaN (Not a Number), 没有意义的数, 称为非数
4. 全0阶码非0尾数: 非规格化数, 可以用于处理阶码下溢
## 定点、浮点表示的区别

|         | 区别                                                                        |
| ------- | ------------------------------------------------------------------------- |
| 数值的表示范围 | 若定点数和浮点数的字长相同, 则**浮点表示的范围远大于定点表示**法                                       |
| 精度      | 对于字长相同的定点数和浮点数, 浮点数虽然扩大了数的表示范围, **但精度降低**了                                |
| 数的运算    | 浮点数包括阶码和尾数两个部分, 运算时不仅要做尾数运算, 还要做阶码的运算, 运算结果要求规格化                          |
| 溢出问题    | 定点运算中, 当运算结果超出数的范围时, 发生溢出<br>浮点运算中, 运算结果超出尾数一定范围却不一定溢出, 只有规格化后阶码超出范围才发生溢出 |

# 2.3.2 浮点数的加减运算

## 对阶

小阶码向大阶码对其, 将阶码小的尾数右移一位, 阶码加1, 直到两个数阶码相等
尾数右移时, 若舍弃有效位会产生误差, 影响精度. 尾数右移时, 低位移出的位不要丢掉, 应保留并参与尾数部分的运算

![[浮点数运算的对阶.png]]

## 尾数相减

## 尾数规格化

## 舍入

在对阶和右规的过程中, 可能会将尾数的低位丢失, 引起误差, 影响了精度, 为此可用舍入法 (低位保留参与运算, 最后将运算结果进行舍入) 来提高尾数的精度

1. 就近舍入: "0舍1入"方式, 
2. 正向舍入: 朝数轴$+\infty$方向舍入, 即取右边最近的可表示数
3. 负向舍入: 朝数轴$-\infty$方向舍入, 即取左边最近的可表示数
4. 截断法: 直接截取所需位数, 丢弃后面所有位. 对于正数和负数来说, 都是取更近原点的可表示数, 是一种趋向原点的舍入

5. "0舍1入"法: 在尾数右移时, 被移去的最高数值为0, 则舍入; 被移去的最高数值为1, 则在尾数的末位加1
   **这样做可能使尾数又溢出, 此时需要再做一次右规**
6. "恒置1"法
   尾数右移时, 不论丢掉的最高位是1还是0, 都使右移后的尾数末位恒置"1", 这种方式同样有使尾数变大和变小的两种可能

>[!attention] 尾数舍入可能引起阶码上溢

## 溢出判断

在尾数规格化和尾数舍入时, 可能会对结果的阶码执行加减运算. 因此, 必须考虑阶码溢出问题
+ **若阶码超过了最大允许值, 则发生上溢, 产生异常**
+ **若阶码超过了最小允许值, 则发生指数下溢, 通常把结果按机器零处理**
**浮点数的溢出并不以尾数溢出来判断**, 尾数溢出可以通过右规操作得到纠正. **运算结果是否溢出主要看结果的指数是否发生了上溢**, 因此是由阶码上溢来判断的

# 2.3.3 C语言中的浮点数类型

+ 等式赋值和判断会导致类型强制转换, 以char->int->long->double和float->double最为常见
+ 不同类型数混合运算是, 遵循的原则是**类型提升**, 这种转换被称为**隐式类型转换**

# 2.3.4 数据的大小端和对其存储

## 数据的"大端方式"和"小端方式"存储

+ 大端方式: 先存储高位字节, 后存储低位字节
+ 小端方式: 先存储低位字节, 后存储高位字节

## 数据按"边界对齐"方式存储

数据按边界对齐方式要求**其存储地址是自生大小的整数倍**: 半字地址一定是2的整数倍, 字地址一定是4的整数倍
当所存数据不满足上述要求时, 可填充空白地址使其符合要求

精简指令系统计算机RISC通常采用边界对齐方式, **边界对齐取指令时间相同, 因此能适应指令流水**

![[按边界对齐存储.png]]

在C语言的struct类型中, 边界对齐有两个重要要求:
1. 每个成员按其类型的大小对齐, char型的对齐值为1, short型的对齐值为2, int型的对齐值为4, 单位为字节
2. struct的长度必须是成员中最大对齐值的整数倍 (不够就补空子节)

编译器要使**结构体成员在空间上对齐**:
1. 每个成员存储的"起始长度%该成员的长度=0", 而结构体的成员都是按定义的先后顺序排放的
2. 结构体的长度也必须是最大成员长度的整数倍