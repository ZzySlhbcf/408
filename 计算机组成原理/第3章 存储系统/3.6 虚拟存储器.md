# 3.6.1 虚拟存储器的基本概念

虚拟存储器将主存或辅存的地址统一编址, 用户可以自由编程
用户编程允许涉及的地址称为虚地址或**逻辑地址**

![[虚拟存储器地址.png]]

>[!attention] 虚拟存储器只能采用回写法
>虚拟存储器采用和Cache类似的技术, 将辅存中经常访问的数据副本存放到主存中. 但是**缺页而访问辅存的代价很大, 提高命中率是关键**'
>+ 虚拟存储器采用**全相联映射**
>
>不能当每次进行写操作都同时写回磁盘
>+ 处理一致性问题时, 采用**回写法**

# 3.6.2 页式虚拟存储器

## 页表

![[主存中的页表示例.png]]

+ 有效位 (装入位): 对应页面是否存在
  若为1, 表示虚拟页已从外存调入主存, 页表项存放**该页的物理页号**
  若为0, 表示没有调入主存, 该页表项可以存放**该页的磁盘地址**
+ 脏位 (修改位): 页面是否被修改过, 虚存机制中采用回写法
+ 引用位 (使用位): 用来配合替换算法, 例如FIFO、LRU

1. 页面长度固定, 页表简单, 调入方便
2. 程序不可能正好是页面的整数倍, 最后一页的零头将无法利用而造成浪费
3. 页不是逻辑上独立的实体, 处理、保护和共享不如段式虚拟存储器方便
## 地址转换

+ 虚拟地址: 高位为**虚页号**, 低位为页内偏移地址
+ 物理地址: 高位为**物理页号**, 低位为页内偏移地址
两者的页面大小是相同的, 页内偏移地址是相等的
虚拟地址到物理地址的转换是由页表实现的, 页表是**存放在主存**的虚拟页号和实页号的对照表

**页表基址寄存器**: 存放该进程的页表首地址
找到对应的页表首地址, 根据虚拟地址的高位的虚拟页号找到对应的页表项

![[页式虚拟存储器的地址变换.png]]
## 快表 (TLB)

由地址转换可知, 访存时先问一次主存去查页表, 再访问主存才能取得数据
采用虚拟存储技术后, 访问主存的次数更多了

依据程序访问的局部性原理, 将一段时间内经常访问的某些页对应的页表项存放在**高速缓冲器组成**的快表(TLB)中, 可以明显提高效率
把存放在主存中的页表称为慢表
地址转换时, 先查找快表, 若命中,则无需访问慢表

快表用SRAM实现, 采用**全相联或组相联映射方式**

TLB表项由页表表项内容和TLB标记组成
+ 全相联: TLB标记就是对应的页表项的虚拟页号
+ 组相联: TLB标记则是对饮的虚拟页号的高位部分, 而虚拟页号的低位部分作为TLB组的组号

## 具有TLB和Cache的多级存储系统

![[TLB和Cache的访问过程.png]]

上图是一个具有TLB和Cache的多级存储系统, 其中Cache采用2路组相联方式.
1. CPU给出一个32位的虚拟地址, TLB采用全相联方式, 每一项都有一个比较器, 查找时将虚页号与每个TLB标记字段同时进行比较
   + 若有某一项相等且对应有效位为1, 则TLB命中, 此时可直接通过TLB进行地址转换
   + 若未命中, 则TLB缺失, 需要访问主存去查页表:
     1. 图中所示的是两级页表方式, 虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项, 从而进行地址转换，并将相应表项调入TLB, 若TLB已满, 则还需要采用替换法
1. 完成由虚拟地址到物理地址的转换后, Cache机构根据映射方式将物理地址划分成多个字段, 然后根据映射规则找到对应的Cache行或组
2. 将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1, 则Cache命中, 此时根据块内地址取出对应的字送给CPU

>[!note] 查找时, 快表和慢表也可同步进行
>若快表有次虚拟号, 则使慢表的查找作废, 这样就能做到虽采用存储器但是访存速度几乎没有下降

![[带TLB虚拟存储器的CPU访存过程.png]]

在一个具有TLB和Cache的多级存储系统中, **CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问**
CPU访存过程中存在三种缺失情况: 
1. TLB缺失: 要访问的页面的页表项不在TLB中
2. Cache缺失: 要访问的主存块不在Cache中
3. Page缺失: 要访问的页面不在主存中
   
TLB只是页表的一部分副本, 因此Page缺失时, TLB也必然缺失
Cache也只是主存的一部分副本, 页表未命中意味着信息不在主存, 因此Page缺失时, Cache也必然缺失

![[TLB、Page、Cache三种缺失的可能性组合.png]]

+ 第1种情况无需访问主存
+ 第2种和第3种需要访问一次主存
+ 第4种需要访问2次主存
+ 第5种发生"缺页异常", 需要访问磁盘, 并且至少访问两次主存

+ Cache缺失处理由硬件完成
+ 缺页处理由软件完成, 操作系统通过"缺页异常处理程序"来实现
+ TLB缺失既可以由硬件完成, 也可以用软件完成
# 3.6.3 段式虚拟存储器

段式虚拟存储器中的段是按程序的逻辑结构划分的, 各个段的长度因程序而异
把虚拟地址分为两部分: 段号和段内地址

虚拟地址到实地址之间的变换是由段表来实现的
段表: 程序的逻辑段和在主存中存放位置的对照表
+ 段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息
+ 段的长度可变, 所以段表中要给出各段的起始地址与段的长度

![[段式虚拟存储器的地址变换过程.png]]

1. CPU根据虚拟地址访存时, 首先根据段表基地址与段号拼接成对应的段表项, 然后根据该段表项的装入位判断该段是否已调入主存
   + 装入位为"1", 表示该段已调入主存
   + 装入位为"0", 表示该段不在主存中
1. 已调入主存时, 从段表读出该段在主存中的起始地址, 与段内地址(偏
移量)相加, 得到对应的主存实地址

+ 段的分界与程序的自然分界相对应, 具有逻辑独立性, 使它易于编译、管理、修改和保护, 也便于多道程序的共享
+ 段长度可变, 分配空间不便, 容易留下碎片, 不好利用, 造成浪费

# 3.6.4 段页式虚拟存储器

在段页式虚拟存储器中, 把程序按逻辑结构分段, 每段再划分为固定大小的页, 主存空间也划分为大小相等的页, 程序对主存的调入, **调出仍以页为基本交换单位**
**每个程序对应一个段表, 每段对应一个页表, 段的长度必须是页长的整数倍, 段的起点必须是某一页的起点**

虚地址分为段号、段内页号、页内地址三部分
1. CPU根据虚地址访存时，首先根据段号得到段表地址
2. 从段表中取出该段的页表起始地址, 与虚地址段内页号合成, 得到页表地址
3. 最后从页表中取出实页号, 与页内地址拼接形成主存实地址


4. 兼具页式和段式虚拟存储器的优点, 可以按段实现共享和保护
5. 在地址变换过程中**需要两次查表**, 系统开销较大

# 3.6.5 虚拟存储器与Cache的比较

| 相同之处                                       | 不同之处                                                                                                                       |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| 都是为了提高系统性能, 两者都有容量、速度、价格的梯度                | + Cache主要解决系统速度<br>+ 虚拟存储器主要解决主存容量                                                                                         |
| 都把数据划分为小信息块, 并作为基本的交换单位, 虚存系统的信息块更大        | + Cache全由硬件实现, 是硬件存储器, 对所有程序员透明<br>+ 虚拟存储器由OS和硬件共同实现, 是逻辑上的存储器, 对系统程序员不透明, 但对应用程序员透明                                       |
| 都有地址映射、替换算法、更新策略等问题                        | 对于不命中性能的影响, CPU的速度约为Cache的10倍, 主存的速度为硬盘的1--倍, **虚拟存储器系统不命中时对系统性能影响更大**                                                     |
| 都依据局部性原理应用"**快速缓存**"的思想, 将活跃的数据存放在相对高速的部件中 | + CPU和Cache和主存都建立了直接访问的通路, 而辅存和CPU没有直接通路<br>+ Cache不命中时主存能和CPU直接通信, 同时将数据调入Cache中<br>+ 虚拟存储器系统不命中时, 只能先由硬盘调入主存, 不能和CPU直接通信 |

